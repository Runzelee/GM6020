/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "can.h"
#include "usart.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

#include <math.h>
#include <stdbool.h>

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
float velocity;
float angle;                // 实时角度（现在为多圈展开的 ticks，单位仍是 0..8191 的基础刻度）

// 新增：多圈展开相关状态
static int32_t angle_wrap_count = 0;    // 环绕计数（每增减一次代表 +/-8192 ticks）
static uint16_t prev_raw_angle = 0;     // 上一次收到的 raw 13-bit 角度
static bool prev_raw_valid = false;     // 是否已有有效的 prev_raw_angle

/* Deadband / hysteresis for angle loop */
static const float ANG_DEAD_ENTER = 300.0f;  // 进入死区阈值 (ticks)
static const float ANG_DEAD_EXIT  = 600.0f;  // 退出死区阈值 (ticks)
static bool hold_position = false;         // 在死区内则保持不输出，直到误差超过退出阈值
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

//extern CAN_HandleTypeDef hcan1;
const uint32_t CAN_CMD_ID = 0x1ff;

/* ---------------- PID parameters & state ---------------- */
static const float Kp = 15.0f;     // 比例 (速度环)
static const float Ki = 5.0f;    // 积分 (速度环)
static const float Kd = 0.0f;     // 微分（速度环）
static const float SAMPLE_DT = 0.05f; // 主循环延时 50 ms

static float pid_integral = 0.0f;
static float pid_prev_error = 0.0f;
static const int16_t MAX_VOLTAGE = 20000; // 输出电压上限，可按需调整

/* --------- 角度外环 PID 参数与状态（产生速度设定） --------- */
static const float Kp_ang = 20.0f;    // 比例 (角度环)
static const float Ki_ang = 5.0f;    // 积分 (角度环)
static const float Kd_ang = 0.0f;    // 微分 (角度环)

static float ang_integral = 0.0f;
static float ang_prev_error = 0.0f;
static const float MAX_TARGET_VEL = 200.0f; // 角度环输出速度上限（rpm），按需调整

/* ---------------- For Debug ---------------- */
float error, derivative, pid_output;
int16_t send_vol;



/* ------------------------------------------ 接收函数 ------------------------------------------ */
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef* hcan)
{
  if (hcan == &hcan1)
  {
      CAN_RxHeaderTypeDef RxHeader;
      uint8_t RxData[8];
      if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData) == HAL_OK)  // 获得接收到的数据头和数据
      {
          // 角度为无符号 0..8191（13-bit），高字节在 RxData[0], 低字节在 RxData[1]
          uint16_t raw_angle = (uint16_t)(((uint16_t)RxData[0] << 8) | (uint16_t)RxData[1]);
          raw_angle &= 0x1FFF; // 保证 13-bit（0..8191）

          // 如果之前没有有效值，初始化 prev_raw_angle
          if (!prev_raw_valid) {
              prev_raw_angle = raw_angle;
              prev_raw_valid = true;
              angle_wrap_count = 0;
          } else {
              // 计算 raw 的差值以检测环绕（unwrap）
              int32_t diff = (int32_t)raw_angle - (int32_t)prev_raw_angle;
              // 若差值超过半圈（>4096），说明发生了回绕
              if (diff > 4096) {
                  // 例如 prev=8000 new=50 -> diff 正很大，实际应为向负方向跨过 8192
                  angle_wrap_count -= 1;
              } else if (diff < -4096) {
                  // 例如 prev=50 new=8000 -> diff 大负，实际应为向正方向跨过 8192
                  angle_wrap_count += 1;
              }
              prev_raw_angle = raw_angle;
          }

          // 多圈展开角度 = raw + wrap_count * 8192
          angle = (float)raw_angle + (float)angle_wrap_count * 8192.0f;

          // 速度为有符号 int16，高字节放在 RxData[2], 低字节在 RxData[3]
          int16_t raw_vel = (int16_t)(((uint16_t)RxData[2] << 8) | (uint16_t)RxData[3]);
          velocity = (float)raw_vel;
      }
  }
  HAL_CAN_ActivateNotification(hcan, CAN_IT_RX_FIFO0_MSG_PENDING);  // 再次使能FIFO0接收中断
}



/* 设定目标角度（单位：ticks）：现在 setpoint_angle 可以是多圈单位，比如 3000 + 8192*turns */

/**
 * @brief 双环 PID 控制到目标角度
 * @param setpoint_angle 目标角度，单位为 ticks（可为多圈展开值，例如：3000 + 8192*turns）
 */
void Double_PID_ToAngle(float setpoint_angle)
{
  // 在循环开始或结束保持与 SAMPLE_DT 对齐
  HAL_Delay((uint32_t)(SAMPLE_DT * 1000)); // 50 ms

  /* -------- 外环：角度 PID（多圈绝对角度），产生速度设定（rpm） -------- */
  // 这里不要再做 fmod 环绕；angle 已经是展开的多圈绝对值，setpoint_angle 也应是相同单位
  float sp = setpoint_angle; // 如果想目标为多圈，可设置为：angle + 3*8192.0f + 3000.0f
  float ang_error = sp - angle;
  // 不再做单圈最短路径的调整

  /* 死区 + 滞回逻辑：误差小于 ANG_DEAD_ENTER 进入保持（停止输出），
      保持状态下误差超过 ANG_DEAD_EXIT 才退出保持 */
  if (hold_position) {
      if (fabsf(ang_error) > ANG_DEAD_EXIT) {
          hold_position = false; // 恢复控制
      }
  } else {
      if (fabsf(ang_error) < ANG_DEAD_ENTER) {
          hold_position = true; // 进入保持
      }
  }

  if (hold_position) {
      // 清零外/内环积分以防止积分风up，并保持输出为 0
      ang_integral = 0.0f;
      ang_prev_error = ang_error;
      pid_integral = 0.0f;
      pid_prev_error = 0.0f;

      float vel_setpoint = 0.0f;
      /* 直接发送 0 输出（位置保持）——后面分支会处理发送 0 电压 */
      pid_output = 0.0f;
  } else {
      ang_integral += ang_error * SAMPLE_DT;
      float ang_derivative = (ang_error - ang_prev_error) / SAMPLE_DT;
      float vel_setpoint = Kp_ang * ang_error + Ki_ang * ang_integral + Kd_ang * ang_derivative;
      ang_prev_error = ang_error;

      // 限幅外环输出到合理的速度范围
      if (vel_setpoint > MAX_TARGET_VEL) vel_setpoint = MAX_TARGET_VEL;
      if (vel_setpoint < -MAX_TARGET_VEL) vel_setpoint = -MAX_TARGET_VEL;

      /* -------- 内环：速度 PID（原有逻辑），使用 vel_setpoint -------- */
      error = vel_setpoint - velocity;
      pid_integral += error * SAMPLE_DT;
      derivative = (error - pid_prev_error) / SAMPLE_DT;

      pid_output = Kp * error + Ki * pid_integral + Kd * derivative;

      pid_prev_error = error;
  }

  /* 无论是否保持，最终输出限幅并发送；保持时 pid_output 已为 0 */
  uint8_t TxData[80];
  /* 发送额外的单圈绝对角度（0..8191） */
  float abs_angle = fmodf(angle, 8192.0f);
  if (abs_angle < 0.0f) abs_angle += 8192.0f;
  sprintf((char *)TxData, "%.2f, %.2f, %.2f, %.2f, %.2f, %d\r\n",
      angle, abs_angle, ang_error, velocity, pid_output, hold_position ? 1 : 0);
  HAL_UART_Transmit(&huart3, TxData, strlen((char *)TxData), 1000);

  // 限幅并转为 int16_t（驱动期望的电压范围）
  if (pid_output > MAX_VOLTAGE) pid_output = MAX_VOLTAGE;
  if (pid_output < -MAX_VOLTAGE) pid_output = -MAX_VOLTAGE;

  send_vol = (int16_t)roundf(pid_output);

  Set_GM6020_Voltage(send_vol);
  //Set_GM6020_Voltage(8000);
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_CAN1_Init();
  MX_USART3_UART_Init();
  /* USER CODE BEGIN 2 */
  

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  Enable_CAN1();
  

  while (1)
  {
    Double_PID_ToAngle(3000 - 8192*2);

    /* USER CODE END WHILE */
    /* USER CODE BEGIN 3 */
  }

  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 168;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
